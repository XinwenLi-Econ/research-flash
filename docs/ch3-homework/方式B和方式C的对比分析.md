# 方式B和方式C的对比分析

---

> 本文档逐一对比方式B（基于42COG Skill生成）与方式C（手动/其他方式生成）产出的文档差异，并给出选用建议。

---

## 零、文档清单对比

| 方式B（3份） | 方式C（4份） |
|-------------|-------------|
| cog.md | cog.md |
| real.md | real.md |
| spec.md（编码规约） | spec-product-requirements.md（PRD） |
| - | spec-user-story.md（用户故事） |

> **关键差异**：方式B产出**1份综合spec**（编码规约），方式C产出**2份分离spec**（PRD + User Story）。

---

## 一、cog.md 对比分析

### 1.1 结构对比

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **文件大小** | 37行 | 35行 |
| **Frontmatter** | `description: ...（简明写法）` | `description: Cognitive model...`（英文） |
| **文档标题** | `# 认知模型 - ResearchFlash` | 无标题 |
| **引言说明** | 包含框架原则说明 | 无引言 |
| **实体标签** | `<flash>` / `<user>` 分离 | `<entity name="flash">` 嵌套 |
| **关系标签** | `<rel>` | `<relationship>` |

### 1.2 XML结构差异

**方式B（分离式实体标签）**：
```xml
<cog>
本系统包括以下关键实体：
- flash：灵感碎片，用户瞬间捕捉的思维片段（核心实体）
- user：使用者，产生灵感的科研人员
</cog>

<flash>
- 唯一编码：创建时间戳（格式：YYYYMMDDHHmm，如 202312221430）
- 常见分类：...
</flash>

<user>
- 唯一编码：设备UUID（本地生成，跨设备不互通）
- 常见分类：本地用户（MVP默认，无需注册登录）
</user>

<rel>
- user-flash：一对多（一个用户拥有多条灵感碎片）
- flash状态流转：孵化中 → 待回顾 → 已归档（单向不可逆）
</rel>
```

**方式C（嵌套式实体标签）**：
```xml
<cog>
本系统包括以下关键实体：
- flash：灵感碎片（核心实体）
- user：使用者（MVP阶段仅用于本地标识）
</cog>

<entity name="flash">
  <unique_id>创建时间戳（格式：YYYYMMDDHHmm，如 202312221430）</unique_id>
  <classification>
    状态（自动流转）：
    - 孵化中 (Incubating)：新建后7天内
    ...
  </classification>
</entity>

<relationship>
user - flash：一对多（一个用户拥有多条灵感）
</relationship>
```

### 1.3 差异分析

| 差异点 | 方式B | 方式C | 影响 |
|--------|-------|-------|------|
| **标签风格** | 语义化自定义标签 | 通用entity嵌套 | 方式B更语义化，方式C更通用 |
| **引言说明** | 包含框架原则 | 无 | 方式B自解释性更强 |
| **标签属性** | 无属性 | `name="..."` 属性 | 方式C更利于程序解析 |
| **关系标签** | `<rel>` 简写 | `<relationship>` 全称 | 方式B更简洁 |
| **状态流转** | 包含在 `<rel>` 中 | 仅在classification中 | 方式B更显式 |

### 1.4 小结

> **核心内容一致，差异在于XML结构风格**：方式B使用skill规范的简明写法，更语义化；方式C使用通用entity嵌套，更利于程序解析。

---

## 二、real.md 对比分析

### 2.1 结构对比

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **文件大小** | 21行 | 14行 |
| **Frontmatter** | `description: ...（简明写法）` | `description: Real-world constraints...`（英文） |
| **文档标题** | `# 现实约束 - ResearchFlash` | `# 现实约束 (Real)` |
| **引言说明** | 包含核心原则（总数限制、关注重点等） | 无引言 |
| **约束内容** | 带括号说明理由 | 仅约束本身 |

### 2.2 内容差异

**方式B（带理由说明）**：
```xml
<real>
- 首屏必须直接展示输入框，无登录或引导页拦截（灵感稍纵即逝，任何阻断都是破坏）
- 单条灵感限制280字以内（强制碎片化，避免用户陷入完美主义陷阱）
- 每周日晚8点推送本周灵感回顾（固定时间锚点，建立用户心理预期）
- 必须支持离线写入，网络恢复后自动同步（科研场景常处于实验室/图书馆等弱网环境）
</real>
```

**方式C（纯约束）**：
```xml
<real>
- 首屏必须直接展示输入框，无登录或引导页拦截
- 单条灵感限制280字以内
- 每周日晚8点推送本周灵感回顾
- 必须支持离线写入，网络恢复后自动同步
</real>
```

### 2.3 差异分析

| 差异点 | 方式B | 方式C | 影响 |
|--------|-------|-------|------|
| **约束数量** | 4条 | 4条 | 一致 |
| **约束内容** | 带理由说明 | 仅约束本身 | 方式B更利于AI理解Why |
| **引言原则** | 显式声明规则 | 无 | 方式B防止约束膨胀 |
| **简洁度** | 较长 | 极简 | 方式C更简洁 |

### 2.4 小结

> **约束内容一致，差异在于是否包含理由说明**。方式B的理由说明有助于AI理解约束背后的设计意图。

---

## 三、spec 文档对比分析（核心差异）

### 3.1 文档结构对比

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **文档数量** | 1份 | 2份 |
| **文档类型** | 编码实现规约 | PRD + User Story |
| **总行数** | ~600行 | PRD ~250行 + Story ~450行 ≈ 700行 |
| **Skill来源** | dev-coding | 未知（可能是pm-product-requirements + pm-user-story） |

### 3.2 方式B spec.md 章节结构

```
一、上下文加载（从cog.md/real.md提取）
二、技术栈锁定
三、文件组织（目录结构）
四、类型定义
五、核心组件实现（FlashInput/CharCounter代码）
六、离线优先架构（IndexedDB代码）
七、API路由实现（route.ts代码）
八、数据库Schema（Drizzle代码）
九、推送调度器（scheduler代码）
十、质量检查清单
十一、约束追溯索引
```

### 3.3 方式C spec 文档结构

**spec-product-requirements.md**：
```
1. 产品环境（名称、标语、环境描述、智能体、核心可供性）
2. 最小可供故事 MAS（MAS-1捕捉、MAS-2重现）
3. 环境约束（物理/结构/安全约束对可供性影响）
4. 感知通道（人类感知、AI感知）
5. 反馈机制（即时/进行中/完成反馈）
6. 验收标准
7. 非可供性（明确不支持的行动）
8. 技术实现要点
9. 附录（状态流转图、MAS优先级）
```

**spec-user-story.md**：
```
- 复杂故事概览（CS-01/CS-02）
- CS-01 灵感捕捉
  - MS-L-01: 首次捕捉灵感（光明）
  - MS-L-02: 离线捕捉灵感（光明）
  - MS-D-01: 字数超限提示（黑暗）
  - MS-G-01: 日常捕捉灵感（灰色）
- CS-02 灵感重现
  - MS-L-03: 首次收到灵感推送（光明）
  - MS-D-02: 无灵感可推送（黑暗）
  - MS-G-02: 每周回顾灵感（灰色）
- 故事地图
- 实施计划
- 测试指南
```

### 3.4 内容深度对比

#### 3.4.1 产品需求层面

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **PRD** | ❌ 无独立PRD | ✅ 完整PRD（可供性理论） |
| **可供性目录** | ❌ 无 | ✅ 3类核心可供性 |
| **MAS（最小可供故事）** | ❌ 无 | ✅ MAS-1/MAS-2详细描述 |
| **感知通道** | ❌ 无 | ✅ 人类感知 + AI感知设计 |
| **反馈机制** | ❌ 无 | ✅ 100ms/1s/5s三级反馈 |
| **非可供性** | ❌ 无 | ✅ 明确列出不支持的行动 |

#### 3.4.2 用户故事层面

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **故事数量** | ❌ 无 | ✅ 7个最小故事 |
| **故事分类** | ❌ 无 | ✅ 光明/黑暗/灰色三类 |
| **故事评估** | ❌ 无 | ✅ 起始→转折→结束状态 |
| **情感体验** | ❌ 无 | ✅ 每个故事的情感曲线 |
| **验收标准** | ❌ 无 | ✅ Given-When-Then格式 |
| **故事地图** | ❌ 无 | ✅ 迭代优先级规划 |
| **测试指南** | ❌ 无 | ✅ 测试用例 |

#### 3.4.3 技术实现层面

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **目录结构** | ✅ 详细 + @R标注 | ❌ 无 |
| **类型定义** | ✅ 完整interface + type | ⚠️ 简要interface |
| **组件代码** | ✅ 完整FlashInput/CharCounter | ❌ 无 |
| **Hook代码** | ✅ useSync Hook | ❌ 无 |
| **API代码** | ✅ 完整route.ts + zod | ❌ 无 |
| **IndexedDB** | ✅ 完整idb.ts代码 | ❌ 无 |
| **Schema** | ✅ Drizzle表定义 | ❌ 无 |
| **调度器** | ✅ triggerWeeklyReview | ❌ 无 |
| **约束追溯** | ✅ @R1-@R4行内注释 | ❌ 无 |

### 3.5 设计理念对比

| 维度 | 方式B | 方式C |
|------|-------|-------|
| **核心理念** | 编码实现规约 | 可供性理论 + 叙事原型 |
| **目标读者** | 开发者 / AI Agent | 产品经理 / 设计师 |
| **关注焦点** | "怎么做"（How） | "做什么 + 为什么"（What + Why） |
| **代码可执行性** | ✅ 可直接复用 | ❌ 需要转译 |
| **产品完整性** | ❌ 缺少PRD/Story | ✅ 完整产品规划 |

### 3.6 独特亮点对比

**方式B独特亮点**：
- `@R1`-`@R4` 行内约束追溯
- 完整可执行代码（组件/Hook/API/Schema）
- 质量检查清单（TypeScript/编码规范）
- 上下文加载章节（显式提取cog/real）

**方式C独特亮点**：
- **可供性理论框架**：感知→行动→闭合
- **三大叙事原型**：光明/黑暗/灰色故事
- **情感体验设计**：每个故事的情感曲线
- **感知通道设计**：人类感知 + AI感知（aria-label、data-*）
- **反馈时序设计**：100ms/1s/5s三级反馈
- **非可供性声明**：明确不支持的行动
- **故事地图**：迭代优先级规划
- **测试指南**：Given-When-Then测试用例

### 3.7 小结

> **方式B是"工程师文档"，方式C是"产品文档"**：
> - 方式B深入编码细节，可直接生成代码
> - 方式C深入产品设计，覆盖可供性、情感体验、感知通道等维度

---

## 四、综合对比总结

### 4.1 总体差异矩阵

| 文档 | 差异程度 | 主要差异点 |
|------|----------|------------|
| **cog.md** | ⭐⭐ 中等 | XML结构风格（分离vs嵌套） |
| **real.md** | ⭐ 低 | 是否包含理由说明 |
| **spec** | ⭐⭐⭐⭐⭐ 高 | 完全不同的文档类型和数量 |

### 4.2 覆盖维度对比

| 维度 | 方式B | 方式C |
|------|:-----:|:-----:|
| **认知模型** | ✅ | ✅ |
| **现实约束** | ✅ | ✅ |
| **PRD（可供性）** | ❌ | ✅ |
| **用户故事** | ❌ | ✅ |
| **感知通道设计** | ❌ | ✅ |
| **情感体验设计** | ❌ | ✅ |
| **技术栈锁定** | ✅ | ⚠️ 简要 |
| **目录结构** | ✅ | ❌ |
| **类型定义** | ✅ | ⚠️ 简要 |
| **组件代码** | ✅ | ❌ |
| **API代码** | ✅ | ❌ |
| **数据库Schema** | ✅ | ❌ |
| **约束追溯** | ✅ | ⚠️ 表格形式 |
| **测试用例** | ❌ | ✅ |
| **故事地图** | ❌ | ✅ |

### 4.3 适用场景建议

| 场景 | 推荐方式 | 理由 |
|------|----------|------|
| **产品规划评审** | 方式C | PRD + User Story完整 |
| **设计师协作** | 方式C | 感知通道 + 反馈机制设计 |
| **AI Agent自动生成代码** | 方式B | 代码可直接执行 |
| **快速原型开发** | 方式B | 完整代码模板 |
| **用户体验设计** | 方式C | 情感体验 + 可供性分析 |
| **测试用例编写** | 方式C | Given-When-Then格式 |
| **全栈独立开发** | **B + C 组合** | 产品 + 工程全覆盖 |

### 4.4 最佳实践建议

**推荐组合使用**：

```
方式C生成 → cog.md + real.md (基础文档)
    ↓
方式C生成 → spec-product-requirements.md (PRD)
    ↓
方式C生成 → spec-user-story.md (用户故事)
    ↓
方式B生成 → spec-coding.md (编码规约)
    ↓
完整的42COG文档体系
```

**文档命名建议**：

```
.42cog/
├── cog.md                        # 认知模型
├── real.md                       # 现实约束
└── spec/
    ├── spec-product-requirements.md  # PRD（方式C）
    ├── spec-user-story.md            # 用户故事（方式C）
    └── spec-coding.md                # 编码规约（方式B）
```

---

## 五、结论

### 5.1 核心发现

1. **cog.md 和 real.md 差异较小**：核心内容一致，仅格式风格不同
2. **spec 文档差异极大**：本质上是两种不同的文档体系
3. **方式B偏工程，方式C偏产品**：互补而非替代

### 5.2 方式特点总结

| 方式 | 特点 | 适合角色 |
|------|------|----------|
| **方式B** | 编码实现规约，代码可执行 | 开发者、AI Agent |
| **方式C** | 产品设计规约，体验完整 | 产品经理、设计师 |

### 5.3 选用指南

| 如果你需要... | 选择 |
|---------------|------|
| 快速生成可执行代码 | 方式B |
| 完整的产品规划文档 | 方式C |
| 用户体验设计参考 | 方式C |
| 测试用例模板 | 方式C |
| 编码规范和质量检查 | 方式B |
| **完整的42COG文档体系** | **B + C 组合** |

### 5.4 改进建议

1. **补充方式B的产品层**：为方式B开发 `pm-product-requirements` 和 `pm-user-story` Skill
2. **补充方式C的编码层**：为方式C补充 `spec-coding.md`
3. **统一XML结构**：建议采用方式B的分离式标签，更语义化
4. **自动串联**：开发元Skill自动调用完整链路

---

*文档生成时间：2024-12-23*
*对比版本：方式B v1.0 vs 方式C v1.0*
