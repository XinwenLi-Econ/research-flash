# 方式A和方式B的对比分析

---

> 本文档逐一对比方式A（自定义Prompt生成）与方式B（基于42COG Skill生成）产出的三份文档差异，并给出选用建议。

---

## 一、cog.md 对比分析

### 1.1 结构对比

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **Frontmatter** | YAML格式，无版本说明 | YAML格式，标注"简明写法" |
| **文档标题** | `# 认知模型 (Cog)` | `# 认知模型 - ResearchFlash` |
| **引言说明** | 项目专属描述（Capture->Sleep->Resurface） | 通用原则说明（智能体+信息+上下文框架） |
| **XML标签** | 相同 | 相同 |
| **实体定义** | 相同 | 相同 |
| **关系定义** | 使用 `->` 箭头 | 使用 `→` 箭头（Unicode） |

### 1.2 内容差异

**方式A 引言**：
```markdown
> 本认知模型服务于科研人员的"放心遗忘"场景，核心机制为 Capture -> Sleep -> Resurface。
```

**方式B 引言**：
```markdown
> 认知模型基于人心系统模型（感性-智商-理商），核心框架是：**智能体 + 信息 + 上下文**
>
> **核心原则**：
> - 每个实体需要：**唯一编码**（如何被识别）、**分类方式**（人类明确，避免AI乱分类）
> - 不是让你掌握很多先验知识，而是让AI意识到你是什么样的人
> - 使用XML语义闭合标签
```

### 1.3 差异分析

| 差异点 | 方式A | 方式B | 影响 |
|--------|-------|-------|------|
| **语境适应性** | 针对本项目定制 | 通用框架说明 | 方式A更聚焦，方式B更规范 |
| **可复用性** | 仅限本项目 | 可被其他Skill调用 | 方式B更适合工具链集成 |
| **学习成本** | 需理解项目背景 | 需理解42COG框架 | 各有门槛 |
| **实体内容** | 完全一致 | 完全一致 | 核心信息无差异 |

### 1.4 小结

> **核心内容一致，差异在于引言说明的风格**：方式A更像"项目文档"，方式B更像"框架规范文档"。

---

## 二、real.md 对比分析

### 2.1 结构对比

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **Frontmatter** | 简单name+description | 标注"简明写法" |
| **文档标题** | `# 现实约束 (Real)` | `# 现实约束 - ResearchFlash` |
| **引言说明** | 项目专属描述 | 通用原则说明 |
| **约束内容** | 完全一致 | 完全一致 |
| **约束数量** | 4条 | 4条 |

### 2.2 内容差异

**方式A 引言**：
```markdown
> 本约束集聚焦于科研场景下的高认知负荷特性，确保"零摩擦捕捉"体验不被破坏。
```

**方式B 引言**：
```markdown
> 现实约束是项目必须遵守的硬性限制，通常来自法律、安全、业务等方面。
>
> **核心原则**：
> - **总数限制**：必选约束最多4条，可选约束最多3条，总共不超过7条
> - **关注重点**：侧重AI不太容易想到的事情，在现实世界中会造成破坏的事项
> - **格式要求**：使用XML语义闭合标签
```

### 2.3 差异分析

| 差异点 | 方式A | 方式B | 影响 |
|--------|-------|-------|------|
| **引言风格** | 项目语境 | 框架规范 | 方式B更适合AI理解约束边界 |
| **规则提示** | 无 | 显式声明总数限制 | 方式B更防止约束膨胀 |
| **约束内容** | 完全一致 | 完全一致 | 核心信息无差异 |

### 2.4 小结

> **约束内容完全一致，差异在于是否显式声明约束规则**。方式B的显式规则有助于在迭代过程中防止约束膨胀。

---

## 三、spec.md 对比分析（核心差异）

### 3.1 结构对比

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **Skill来源** | 自定义Prompt（42COG架构师角色） | dev-coding Skill |
| **文档类型** | 综合规约（PRD+UserStory+Sys） | 编码实现规约 |
| **章节数** | 5章 | 11章 |
| **代码示例** | 类型定义+架构图 | 完整组件/Hook/API代码 |
| **行数** | ~330行 | ~600行 |

### 3.2 章节结构对比

| 方式A 章节 | 方式B 章节 |
|------------|------------|
| 一、产品需求 (PRD) | 一、上下文加载 |
| 二、用户故事 (User Story) | 二、技术栈锁定 |
| 三、系统架构 (Sys) | 三、文件组织 |
| 四、验收标准清单 | 四、类型定义 |
| 五、约束引用索引 | 五、核心组件实现 |
| - | 六、离线优先架构 |
| - | 七、API 路由实现 |
| - | 八、数据库 Schema |
| - | 九、推送调度器 |
| - | 十、质量检查清单 |
| - | 十一、约束追溯索引 |

### 3.3 内容深度对比

#### 3.3.1 产品需求层面

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **PRD** | ✅ 完整PRD（可供性目录、MAS） | ❌ 无PRD |
| **User Story** | ✅ 9个故事（光明/黑暗/灰色分类） | ❌ 无User Story |
| **验收标准** | ✅ 7项MVP验收标准 | ❌ 无独立验收标准 |

#### 3.3.2 技术实现层面

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **目录结构** | 简要列出 | 详细列出 + @R标注 |
| **类型定义** | interface + enum | interface + type + JSDoc注释 |
| **组件代码** | ❌ 无 | ✅ 完整FlashInput/CharCounter |
| **Hook代码** | ❌ 无 | ✅ useSync Hook |
| **API代码** | ❌ 无 | ✅ 完整route.ts + zod校验 |
| **IndexedDB** | 流程图描述 | ✅ 完整idb.ts代码 |
| **Schema** | ❌ 无 | ✅ Drizzle表定义 |
| **调度器** | ❌ 无 | ✅ triggerWeeklyReview函数 |

#### 3.3.3 约束追溯方式

| 方式A | 方式B |
|-------|-------|
| 表格引用（约束ID → 规约位置） | `@R1` 行内注释 + 追溯表 |
| 集中在文档末尾 | 分散在代码注释 + 集中表格 |

### 3.4 代码示例对比

**方式A（仅类型定义）**：
```typescript
interface Flash {
  id: string;              // 时间戳编码: YYYYMMDDHHmm
  content: string;         // 内容，max 280字符
  status: FlashStatus;     // 状态枚举
  createdAt: Date;         // 创建时间
  syncedAt: Date | null;   // 同步时间（离线场景）
}
```

**方式B（完整组件代码）**：
```typescript
// components/FlashInput.tsx
// @source: real.md R1, R2
'use client';

import { useState, useCallback, useRef, useEffect } from 'react';
import { CharCounter } from './CharCounter';
import { useFlash } from '@/hooks/useFlash';
import { useOffline } from '@/hooks/useOffline';

const MAX_LENGTH = 280; // @R2

export function FlashInput() {
  // ... 完整实现
}
```

### 3.5 差异分析

| 差异点 | 方式A | 方式B | 适用场景 |
|--------|-------|-------|----------|
| **侧重点** | 产品规划 | 编码实现 | A适合产品经理，B适合开发者 |
| **代码量** | 低 | 高 | A需二次转化，B可直接复用 |
| **可执行性** | 需要人工转译 | AI可直接生成 | B更适合Agent自动化 |
| **完整性** | PRD+Story全 | 仅编码规约 | A覆盖产品全貌，B深入实现细节 |
| **约束追溯** | 集中式 | 分布式+集中式 | B追溯更细粒度 |

### 3.6 小结

> **方式A是"产品规约"，方式B是"编码规约"**。两者不是替代关系，而是互补关系：
> - 方式A 回答"做什么"和"为什么做"
> - 方式B 回答"怎么做"

---

## 四、综合对比总结

### 4.1 总体差异矩阵

| 文档 | 差异程度 | 主要差异点 |
|------|----------|------------|
| cog.md | ⭐ 低 | 引言风格（项目vs框架） |
| real.md | ⭐ 低 | 引言风格（项目vs框架） |
| spec.md | ⭐⭐⭐⭐⭐ 高 | 完全不同的文档类型 |

### 4.2 生成效率对比

| 维度 | 方式A | 方式B |
|------|-------|-------|
| **Prompt复杂度** | 高（需完整角色设定） | 低（调用Skill即可） |
| **生成一致性** | 依赖Prompt质量 | Skill模板保证一致 |
| **可复现性** | 中等 | 高 |
| **定制灵活性** | 高 | 低（受限于Skill模板） |

### 4.3 适用场景建议

| 场景 | 推荐方式 | 理由 |
|------|----------|------|
| **快速原型** | 方式A | 一次生成PRD+Story+架构 |
| **团队协作** | 方式B | Skill保证文档一致性 |
| **AI Agent自动化** | 方式B | 编码规约可直接执行 |
| **产品评审** | 方式A | PRD和User Story更完整 |
| **代码生成** | 方式B | 组件/API代码可直接复用 |
| **新手学习42COG** | 方式B | Skill包含框架原则说明 |

### 4.4 最佳实践建议

**推荐组合使用**：

```
方式A生成 → cog.md + real.md + spec.md (PRD/Story)
    ↓
方式B生成 → spec-coding.md (编码实现)
    ↓
合并为完整规约体系
```

或者：

```
方式B生成 → cog.md + real.md (基础文档)
    ↓
方式A补充 → PRD + User Story (产品规划)
    ↓
方式B生成 → spec-coding.md (编码实现)
```

---

## 五、结论

### 5.1 核心发现

1. **cog.md 和 real.md 差异极小**：核心内容完全一致，仅引言风格不同
2. **spec.md 差异极大**：本质上是两种不同类型的文档
3. **方式A偏产品，方式B偏工程**：互补而非替代

### 5.2 选用指南

| 如果你是... | 推荐使用 |
|-------------|----------|
| 产品经理 | 方式A（获得完整PRD和User Story） |
| 开发者 | 方式B（获得可执行的编码规约） |
| AI Agent | 方式B（代码可直接复制执行） |
| 全栈独立开发者 | 方式A + 方式B 组合 |

### 5.3 改进建议

1. **统一命名**：方式A的spec.md应改名为 `spec-prd.md`，与方式B的 `spec-coding.md` 区分
2. **补充Skill**：为方式B开发 `pm-prd` 和 `pm-userstory` Skill，补齐产品规划层
3. **自动串联**：开发元Skill自动调用 `meta-42cog` → `pm-prd` → `dev-coding` 完整链路

---

*文档生成时间：2024-12-23*
*对比版本：方式A v1.0 vs 方式B v1.0*
